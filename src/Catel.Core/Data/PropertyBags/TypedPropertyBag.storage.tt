<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
	var typeCodes = Enum.GetValues(typeof(TypeCode));
#>

//------------------------------------------------------------------------------ 
// <auto-generated> 
// This code was generated by a tool. 
// 
// Changes to this file may cause incorrect behavior and will be lost if 
// the code is regenerated. 
// </auto-generated> 
//------------------------------------------------------------------------------


namespace Catel.Data
{
    using System;
    using System.Linq;
    using System.Collections.Generic;
    using Catel.Reflection;

    public partial class TypedPropertyBag
    {
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull)
	{
		continue;
	}

    string storageType = "Dictionary<string, " + typeCode.ToString() + ">";
	string storageName = "_" + typeCode.ToString().ToLowerInvariant() + "SettersCache";

#>
        private <#= storageType #> <#= storageName #>;
<#
}
#>

<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull)
	{
		continue;
	}

    string storageType = "Dictionary<string, " + typeCode.ToString() + ">";
	string storageName = "_" + typeCode.ToString().ToLowerInvariant() + "SettersCache";

#>
        protected <#= storageType #> Get<#= typeCode.ToString() #>Storage()
        {
            if (<#= storageName #> is null)
            {
                <#= storageName #> = new <#= storageType #>();
            }

            return <#= storageName #>;
        }

<#
}
#>

        public override TValue GetValue<TValue>(string name, TValue defaultValue = default)
        {
            Argument.IsNotNullOrWhitespace(nameof(name), name);

            var targetValue = typeof(TValue);

<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull || typeCode == TypeCode.Object)
	{
		continue;
	}
#>
            if (targetValue == typeof(<#= typeCode.ToString() #>))
            {
                var storage = Get<#= typeCode.ToString() #>Storage();

                lock (storage)
                {
                    if (storage.TryGetValue(name, out var bagValue))
                    {
                        var tr = __makeref(bagValue);
                        var value = __refvalue(tr, TValue);
                        return value;
                    }
                }

                return default;
            }
<#
}
#>

            // Fallback to object store
            {
                var storage = GetObjectStorage();

                lock (storage)
                {
                    if (storage.TryGetValue(name, out var bagValue))
                    {
                        var tr = __makeref(bagValue);
                        var value = __refvalue(tr, TValue);
                        return value;
                    }
                }

                return default;
            }
        }

        public override void SetValue<TValue>(string name, TValue value)
        {
            Argument.IsNotNullOrWhitespace(nameof(name), name);

            var raisePropertyChanged = false;

            var targetValue = typeof(TValue);
            if (false) 
            {
                // dummy code to enable switches
            }
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull || typeCode == TypeCode.Object)
	{
		continue;
	}
#>
            else if (targetValue == typeof(<#= typeCode.ToString() #>))
            {
                EnsureIntegrity(name, typeof(TValue));

                var tr = __makeref(value);
                var bagValue = __refvalue(tr, <#= typeCode.ToString() #>);
                var storage = Get<#= typeCode.ToString() #>Storage();

                lock (storage)
                {
                    if (!storage.TryGetValue(name, out var propertyValue) || propertyValue != bagValue)
                    {
                        storage[name] = bagValue;
                        raisePropertyChanged = true;
                    }
                }
            }
<#
}
#>

            // Fallback to object store
            else 
            {
                EnsureIntegrity(name, typeof(TValue));

                var tr = __makeref(value);
                var bagValue = __refvalue(tr, object);
                var storage = GetObjectStorage();

                lock (storage)
                {
                    if (!storage.TryGetValue(name, out var propertyValue) || !ObjectHelper.AreEqualReferences(propertyValue, bagValue))
                    {
                        storage[name] = bagValue;
                        raisePropertyChanged = true;
                    }
                }
            }

            if (raisePropertyChanged)
            {
                RaisePropertyChanged(name);
            }
        }
    }
}