<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
	var typeCodes = Enum.GetValues(typeof(TypeCode));
#>

//------------------------------------------------------------------------------ 
// <auto-generated> 
// This code was generated by a tool. 
// 
// Changes to this file may cause incorrect behavior and will be lost if 
// the code is regenerated. 
// </auto-generated> 
//------------------------------------------------------------------------------


namespace Catel.Data
{
    using System;
    using System.Linq;
    using System.Collections.Generic;
    using Catel.Logging;
    using Catel.Reflection;

    public partial class TypedPropertyBag
    {
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull)
	{
		continue;
	}

    string storageType = "Dictionary<string, " + typeCode.ToString() + ">";
	string storageName = "_" + typeCode.ToString().ToLowerInvariant() + "Storage";

#>
        private <#= storageType #> <#= storageName #>;
<#
}
#>

<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull)
	{
		continue;
	}

    string storageType = "Dictionary<string, " + typeCode.ToString() + ">";
	string storageName = "_" + typeCode.ToString().ToLowerInvariant() + "Storage";

#>
        protected <#= storageType #> Get<#= typeCode.ToString() #>Storage()
        {
            if (<#= storageName #> is null)
            {
                <#= storageName #> = new <#= storageType #>();
            }

            return <#= storageName #>;
        }

<#
}
#>

        public override TValue GetValue<TValue>(string name, TValue defaultValue = default)
        {
            Argument.IsNotNullOrWhitespace(nameof(name), name);

            // Get from the right dictionary and see if we need to convert to TValue
            var propertyType = GetRegisteredPropertyType(name);
            if (propertyType is null)
            {
                // Not registered!
                return defaultValue;
            }

            var targetType = typeof(TValue);

<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull || typeCode == TypeCode.Object)
	{
		continue;
	}
#>
            // Important: compare against the *actual* property type so we use the correct property bag
            // to retrieve the value
            if (propertyType == typeof(<#= typeCode.ToString() #>))
            {
                var storage = Get<#= typeCode.ToString() #>Storage();

                lock (storage)
                {
                    if (storage.TryGetValue(name, out var bagValue))
                    {
                        // Special case when GetValue<object> is used to retrieve this value type
                        if (targetType == typeof(object))
                        {
                            // Get boxed value (prevent single boxing) and return as object
                            return (TValue)(object)BoxingCache.GetBoxedValue(bagValue);
                        }

                        // Simply cast to the requested type
                        var tr = __makeref(bagValue);
                        var value = __refvalue(tr, TValue);

                        return value;
                    }
                }

                return default;
            }

<#
}
#>

            // Fallback to object store
            {
                var storage = GetObjectStorage();

                lock (storage)
                {
                    if (storage.TryGetValue(name, out var bagValue))
                    {
                        // Simply cast
                        //var tr = __makeref(bagValue);
                        //var value = __refvalue(tr, TValue);
                        return (TValue)bagValue;
                    }
                }

                return default;
            }
        }

        public override void SetValue<TValue>(string name, TValue value)
        {
            Argument.IsNotNullOrWhitespace(nameof(name), name);

            var stored = false;
            var raisePropertyChanged = false;

            var targetType = typeof(TValue);
            if (typeof(TValue) == typeof(object)) 
            {
                // If users use SetValue<object>(), we might need to convert
                var propertyType = GetRegisteredPropertyType(name);
                if (propertyType is null == false)
                {
                    if (propertyType.IsValueTypeEx() && value is null)
                    {
                        throw Log.ErrorAndCreateException<InvalidOperationException>($"Property '{name}' cannot be updated with a null value since it represents a value of '{propertyType.FullName}'");
                    }

                    // Slowest path, we need to cast and store in the right dictionary
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull || typeCode == TypeCode.Object)
	{
		continue;
	}
#>
                    if (propertyType == typeof(<#= typeCode.ToString() #>))
                    {
                        //if (value is <#= typeCode.ToString() #> typedValue)
                        //{
                        var castValue = (<#= typeCode.ToString() #>)(object)value;
                        SetValue<<#= typeCode.ToString() #>>(name, castValue);
                        return;
                        //}
                    }

<#
}
#>
                    // Fallback to object storage
                }
            }
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull || typeCode == TypeCode.Object)
	{
		continue;
	}
#>
            if (!stored && targetType == typeof(<#= typeCode.ToString() #>))
            {
                EnsureIntegrity(name, typeof(TValue));

                var tr = __makeref(value);
                var bagValue = __refvalue(tr, <#= typeCode.ToString() #>);
                var storage = Get<#= typeCode.ToString() #>Storage();

                lock (storage)
                {
                    if (!storage.TryGetValue(name, out var propertyValue) || propertyValue != bagValue)
                    {
                        storage[name] = bagValue;
                        raisePropertyChanged = true;
                    }
                }

                stored = true;
            }

<#
}
#>

            if (!stored)
            {
                // Just store as object (and check integrity as object)
                EnsureIntegrity(name, typeof(object));

                // No need for special casting, just store as object
                //var tr = __makeref(value);
                //var bagValue = __refvalue(tr, object);
                var storage = GetObjectStorage();

                lock (storage)
                {
                    if (!storage.TryGetValue(name, out var propertyValue) || !ObjectHelper.AreEqualReferences(propertyValue, value))
                    {
                        storage[name] = value;
                        raisePropertyChanged = true;
                    }
                }

                stored = true;
            }

            if (raisePropertyChanged)
            {
                RaisePropertyChanged(name);
            }
        }

        public override Dictionary<string, object> GetAllProperties()
        {
            var values = new Dictionary<string, object>();

            // Note: don't use methods, we don't want to lazy-instantiate the storage
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull || typeCode == TypeCode.Object)
	{
		continue;
	}

    var storageName = typeCode.ToString().ToLowerInvariant() + "Storage";
#>
            var <#= storageName #> = _<#= storageName #>;
            if (<#= storageName #> is null == false)
            {
                 // Unfortunately we have to box to object here...
                 foreach (var propertyPair in <#= storageName #>)
                 {
                     values[propertyPair.Key] = BoxingCache.GetBoxedValue(propertyPair.Value);
                 }
            }

<#
}
#>

            var objectStorage = _objectStorage;
            if (objectStorage is null == false)
            {
                foreach (var propertyPair in objectStorage)
                {
                    values[propertyPair.Key] = propertyPair.Value;
                }
            }

            return values;
        }
    }
}