<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
	var typeCodes = Enum.GetValues(typeof(TypeCode));
#>
//------------------------------------------------------------------------------ 
// <auto-generated> 
// This code was generated by a tool. 
// 
// Changes to this file may cause incorrect behavior and will be lost if 
// the code is regenerated. 
// </auto-generated> 
//------------------------------------------------------------------------------

namespace Catel.Reflection
{
	using System;
    using System.Collections.Concurrent;
	using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using Catel.Linq.Expressions;

	public partial class FastMemberInvoker<TEntity>
	{
<# 
foreach (TypeCode typeCode in typeCodes) 
{
	if (typeCode == TypeCode.Empty || typeCode == TypeCode.DBNull)
	{
		continue;
	}

	string typeCodeSetterCacheName = "_" + typeCode.ToString().ToLowerInvariant() + "SettersCache";
	string typeCodeGetterCacheName = "_" + typeCode.ToString().ToLowerInvariant() + "GettersCache";
#>
		private readonly ConcurrentDictionary<string, Func<TEntity, <#= typeCode #>>> <#= typeCodeGetterCacheName #> = new ConcurrentDictionary<string, Func<TEntity, <#= typeCode #>>>();
		private readonly ConcurrentDictionary<string, Action<TEntity, <#= typeCode #>>> <#= typeCodeSetterCacheName #> = new ConcurrentDictionary<string, Action<TEntity, <#= typeCode #>>>();

        private Func<TEntity, <#= typeCode #>> Get<#= typeCode #>FieldGetter(string memberName)
        {
            var key = $"field_{memberName}_as_<#= typeCode #>";

            if (!<#= typeCodeGetterCacheName #>.TryGetValue(key, out var getter))
            {
                var getterExpression = ExpressionBuilder.CreateFieldGetter<TEntity, <#= typeCode #>>(memberName);
                if (getterExpression is not null)
                {
                    getter = Compile(getterExpression);
                    <#= typeCodeGetterCacheName #>[key] = getter;
                }
            }

            return getter;
        }

        private Func<TEntity, <#= typeCode #>> Get<#= typeCode #>PropertyGetter(string memberName)
        {
            var key = $"property_{memberName}_as_<#= typeCode #>";

            if (!<#= typeCodeGetterCacheName #>.TryGetValue(key, out var getter))
            {
                var getterExpression = ExpressionBuilder.CreatePropertyGetter<TEntity, <#= typeCode #>>(memberName);
                if (getterExpression is not null)
                {
                    getter = Compile(getterExpression);
                    <#= typeCodeGetterCacheName #>[key] = getter;
                }
            }

            return getter;
        }

        private Action<TEntity, <#= typeCode #>> Get<#= typeCode #>FieldSetter(string memberName)
        {
            var key = $"field_{memberName}_as_<#= typeCode #>";

            if (!<#= typeCodeSetterCacheName #>.TryGetValue(key, out var setter))
            {
                var setterExpression = ExpressionBuilder.CreateFieldSetter<TEntity, <#= typeCode #>>(memberName);
                if (setterExpression is not null)
                {
                    setter = Compile(setterExpression);
                    <#= typeCodeSetterCacheName #>[key] = setter;
                }
            }

            return setter;
        }

        private Action<TEntity, <#= typeCode #>> Get<#= typeCode #>PropertySetter(string memberName)
        {
            var key = $"property_{memberName}_as_<#= typeCode #>";

            if (!<#= typeCodeSetterCacheName #>.TryGetValue(key, out var setter))
            {
                var setterExpression = ExpressionBuilder.CreatePropertySetter<TEntity, <#= typeCode #>>(memberName);
                if (setterExpression is not null)
                {
                    setter = Compile(setterExpression);
                    <#= typeCodeSetterCacheName #>[key] = setter;
                }
            }

            return setter;
        }

<# } #>
	}
}